using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public abstract class Plane : Alive {



    
    [SerializeField] private float m_MaxEnginePower = 40f;        // The maximum output of the engine.
    [SerializeField] private float m_Lift = 0.002f;               // The amount of lift generated by the aeroplane moving forwards.
    [SerializeField] private float m_ZeroLiftSpeed = 300;         // The speed at which lift is no longer applied.
    [SerializeField] private float m_PitchEffect = 1f;            // The strength of effect for pitch input.
    [SerializeField] private float m_AerodynamicEffect = 0.02f;   // How much aerodynamics affect the speed of the aeroplane.
    [SerializeField] private float m_AirBrakesEffect = 3f;        // How much the air brakes effect the drag.
    [SerializeField] private float m_ThrottleChangeSpeed = 0.3f;  // The speed with which the throttle changes.
    [SerializeField] private float m_DragIncreaseFactor = 0.001f; // how much drag should increase with speed.
    [SerializeField] private float m_torqueFactor = 0.1f;

    [SerializeField] private float currentForwardSpeed = 0.0f;

    public float Throttle { get; private set; }                     // The amount of throttle being used.
    public bool AirBrakes { get; private set; }                     // Whether or not the air brakes are being applied.
    public float ForwardSpeed { get; private set; }                 // How fast the aeroplane is traveling in it's forward direction.
    public float EnginePower { get; private set; }                  // How much power the engine is being given.
    public float MaxEnginePower { get { return m_MaxEnginePower; } }    // The maximum output of the engine.

    public float PitchAngle { get; private set; }
    public float PitchInput { get; private set; }
    public float ThrottleInput { get; private set; }

    private float m_OriginalDrag;         // The drag when the scene starts.
    private float m_OriginalAngularDrag;  // The angular drag when the scene starts.
    private float m_AeroFactor;

    private Rigidbody2D m_Rigidbody;


    private void Start()
    {
        m_Rigidbody = GetComponent<Rigidbody2D>();
        // Store original drag settings, these are modified during flight.
        m_OriginalDrag = m_Rigidbody.drag;
        m_OriginalAngularDrag = m_Rigidbody.angularDrag;

        Vector2 currentVelo = m_Rigidbody.velocity;
        currentVelo.x = 150;

        m_Rigidbody.velocity = currentVelo;
    }

    // Update is called once per frame
    void Update()
    {

    }


    public void Move(float pitchInput, float throttleInput, bool airBrakes)
    {

        PitchInput = pitchInput;

        ThrottleInput = throttleInput;
        AirBrakes = airBrakes;

        ClampInputs();

        CalculateRollAndPitchAngles();

        CalculateForwardSpeed();

        ControlThrottle();

        CalculateDrag();

        CaluclateAerodynamicEffect();

        CalculateLinearForces();

        CalculateTorque();

        currentForwardSpeed = m_Rigidbody.velocity.x;
    }


    private void ClampInputs()
    {
        // clamp the inputs to -1 to 1 range
        PitchInput = Mathf.Clamp(PitchInput, -1, 1);

        ThrottleInput = Mathf.Clamp(ThrottleInput, -1, 1);
    }


    private void CalculateRollAndPitchAngles()
    {
        // Calculate roll & pitch angles
        // Calculate the flat forward direction (with no y component).
        var flatForward = transform.right;
        flatForward.y = 0;
        // If the flat forward vector is non-zero (which would only happen if the plane was pointing exactly straight upwards)
        if (flatForward.sqrMagnitude > 0)
        {
            flatForward.Normalize();
            // calculate current pitch angle
            var localFlatForward = transform.InverseTransformDirection(flatForward);
            PitchAngle = Mathf.Atan2(localFlatForward.y, localFlatForward.x);
            //Debug.Log("PitchAngle: " + PitchAngle);
        }
    }


    private void CalculateForwardSpeed()
    {
        // Forward speed is the speed in the planes's forward direction (not the same as its velocity, eg if falling in a stall)
        var localVelocity = transform.InverseTransformDirection(m_Rigidbody.velocity);
        ForwardSpeed = Mathf.Max(0, Mathf.Abs(localVelocity.x));
    }


    private void ControlThrottle()
    {
        // Adjust throttle based on throttle input (or immobilized state)
        Throttle = Mathf.Clamp01(Throttle + ThrottleInput * Time.deltaTime * m_ThrottleChangeSpeed);

        // current engine power is just:
        EnginePower = Throttle * m_MaxEnginePower;
    }


    private void CalculateDrag()
    {
        // increase the drag based on speed, since a constant drag doesn't seem "Real" (tm) enough
        float extraDrag = m_Rigidbody.velocity.magnitude * m_DragIncreaseFactor;
        // Air brakes work by directly modifying drag. This part is actually pretty realistic!
        m_Rigidbody.drag = (AirBrakes ? (m_OriginalDrag + extraDrag) * m_AirBrakesEffect : m_OriginalDrag + extraDrag);
        // Forward speed affects angular drag - at high forward speed, it's much harder for the plane to spin
        m_Rigidbody.angularDrag = m_OriginalAngularDrag * ForwardSpeed;
    }


    private void CaluclateAerodynamicEffect()
    {
        // "Aerodynamic" calculations. This is a very simple approximation of the effect that a plane
        // will naturally try to align itself in the direction that it's facing when moving at speed.
        // Without this, the plane would behave a bit like the asteroids spaceship!
        if (m_Rigidbody.velocity.magnitude > 0)
        {
            // compare the direction we're pointing with the direction we're moving:
            m_AeroFactor = Vector2.Dot(transform.right, m_Rigidbody.velocity.normalized);
            //Debug.Log("Transform.Right: " + transform.right);
            //Debug.Log("Rigidbody Velocity: " + m_Rigidbody.velocity.normalized);
            //Debug.Log("Dot: " + Vector2.Dot(transform.right, m_Rigidbody.velocity.normalized));
            // multipled by itself results in a desirable rolloff curve of the effect
            m_AeroFactor *= m_AeroFactor;
            Debug.Log("AeroFactor: " + m_AeroFactor);
            // Finally we calculate a new velocity by bending the current velocity direction towards
            // the the direction the plane is facing, by an amount based on this aeroFactor
            var newVelocity = Vector2.Lerp(m_Rigidbody.velocity, transform.right * ForwardSpeed,
                                           m_AeroFactor * ForwardSpeed * m_AerodynamicEffect * Time.deltaTime);
            //Debug.Log("prevVelo: " + m_Rigidbody.velocity);
            m_Rigidbody.velocity = newVelocity;
            //Debug.Log("newVelo: " + m_Rigidbody.velocity);

            // also rotate the plane towards the direction of movement - this should be a very small effect, but means the plane ends up
            // pointing downwards in a stall
            Quaternion lookRotation = Quaternion.LookRotation(m_Rigidbody.velocity, transform.up);

            Quaternion slerpB = new Quaternion(0, 0, lookRotation.z, lookRotation.w);
            m_Rigidbody.rotation = Quaternion.Slerp(Quaternion.Euler(0, 0, m_Rigidbody.rotation),
                                                  slerpB,
                                                  m_AerodynamicEffect * Time.deltaTime).eulerAngles.z;
        }
    }


    private void CalculateLinearForces()
    {
        // Now calculate forces acting on the aeroplane:
        // we accumulate forces into this variable:
        var forces = Vector3.zero;
        // Add the engine power in the forward direction
        forces += EnginePower * transform.right;
        // The direction that the lift force is applied is at right angles to the plane's velocity (usually, this is 'up'!)
        var liftDirection = Vector3.Cross(m_Rigidbody.velocity, transform.right).normalized;
        // The amount of lift drops off as the plane increases speed - in reality this occurs as the pilot retracts the flaps
        // shortly after takeoff, giving the plane less drag, but less lift. Because we don't simulate flaps, this is
        // a simple way of doing it automatically:
        var zeroLiftFactor = Mathf.InverseLerp(m_ZeroLiftSpeed, 0, ForwardSpeed);
        // Calculate and add the lift power
        var liftPower = ForwardSpeed * ForwardSpeed * m_Lift * zeroLiftFactor * m_AeroFactor;
        forces += liftPower * liftDirection;
        // Apply the calculated forces to the the Rigidbody
        m_Rigidbody.AddForce(forces);
    }


    private void CalculateTorque()
    {
        var torque = PitchInput * m_PitchEffect;

        m_Rigidbody.AddTorque(torque * ForwardSpeed * m_AeroFactor * m_torqueFactor);
    }
    override protected void EventByDesiredHealthPoint(float hp)
    {
        if (hp <= 0)
            Destroy(gameObject);
    }
}
